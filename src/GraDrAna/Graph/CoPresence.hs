{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE TupleSections #-}

-- | Construct a graph on the basis of whether two characters are both
-- present in at least one unit (time slice or scene or something
-- else). The resulting graph's edges do not have a direction. Each
-- edge's label represents the number of units (time slices), in which
-- the two persons are both present.

-- | Combined with the time slice splitter this implements the
-- approach of J. Stiller et al. 2003.

module GraDrAna.Graph.CoPresence
  ( copresenceIO
  , copresence
  -- * helper functions
  , mkMapTuples
  , foldTuples
  ) where

--import Data.Graph.Inductive
import qualified Data.Map as Map
import Data.List
import Data.Maybe
import Control.Lens

import GraDrAna.TypeDefs

-- | Abstract type alias for abstract helper functions
type Mappy k a = (Ord k) => Map.Map k (Map.Map k a)

-- | Intermediate data structure for co-present persons of the
-- play. It's a map of maps, the outer representing the persons (ids
-- only) in the play and the inner representing the edges to other
-- persons.
type CoMap = Mappy PersonId Int

-- | Run 'copresence' in the IO monad. The signature fits the data
-- flow.
copresenceIO :: Persons -> [[Turn]] -> IO (Persons, [[Turn]])
copresenceIO reg turns = return ((copresence reg turns), turns) 

-- | Calculate the co-present persons from the turns. This is the
-- workhorse of the construction of the copresence graph. The edges
-- are stored to the map of 'Person' records. It's not a graph, but
-- aggregate data for constructing the graph.
copresence :: Persons -> [[Turn]] -> Persons
copresence reg turns = toRegistry reg $ foldTuples (+) $ mkMapTuples 1 $ speakers turns

-- | Get the speakers from the turns.
speakers :: [[Turn]] -> [[PersonId]]
speakers turns = map getSpeakers turns
  where
    getSpeakers = map ((fromMaybe "UNKOWN") . _turn_roleId)

-- | Feed 'CoMap' into the registry of persons.
toRegistry :: Persons -> CoMap -> Persons
toRegistry reg cs =
  Map.mapWithKey
  (\k p -> p & person_edgesTo .~ (fromMaybe Map.empty $ Map.lookup k cs))
  reg  

-- * Helper Functions

-- | 'mkMapTuples' and 'foldTuples' are the workhorses of generating
-- data representing copresence in a play. These functions are very
-- generic.

-- | Fold the result of 'mkMapTuples' into a map of maps.
foldTuples ::
  Ord k
  => (a -> a -> a) -- ^ a function used for making the map values when
                   -- making the union of maps.
  -> [[(k, Map.Map k a)]] -- ^ the list of lists generated by 'mkMapTuples'
  -> Mappy k a
foldTuples f tups = foldl (Map.unionWith (Map.unionWith f)) Map.empty $ map foldTuples' tups

foldTuples' :: Ord k => [(k, Map.Map k a)] -> Mappy k a
foldTuples' tups =
  foldl
  (\reg tup -> Map.insertWith Map.union (fst tup) (snd tup) reg)
  Map.empty
  tups

mkTuples :: (Eq a) => [[a]] -> [[(a, [a])]]
mkTuples = map ((\l -> map (\p -> (p, delete p l)) l) . nub)

-- | For a list of lists of keys, where a list of keys represent the
-- speakers of a time slice (or scene), make a list of lists of
-- tuples, where a list of tuples represent the copresent persons of
-- the time slice, each person a tuple. The tuple consist of the key
-- (person id) and a map of copresent persons. This resulting
-- datastructure is to folded using 'foldTuples'. The usage of
-- 'Map.Map' makes folding faster.
mkMapTuples ::
  (Eq k, Ord k)
  => a -- ^ Initial value of the map entry. 1::int is a reasonable value.
  -> [[k]] -- ^ a list of list of mapping keys
  -> [[(k, Map.Map k a)]]
mkMapTuples ini = map ((\l -> map (\p -> (p, Map.fromList (map (, ini) $ delete p l))) l) . nub)
